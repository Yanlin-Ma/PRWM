!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.prwm=e()}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){"use strict";module.exports={AttributeTypes:require("./prwm/attribute-types"),MeshTypes:require("./prwm/mesh-types"),isBigEndianPlatform:require("./utils/is-big-endian-platform"),encodePrwm:require("./prwm/encode"),decodePrwm:require("./prwm/decode")}},{"./prwm/attribute-types":2,"./prwm/decode":3,"./prwm/encode":4,"./prwm/mesh-types":5,"./utils/is-big-endian-platform":6}],2:[function(require,module,exports){"use strict";module.exports={Int:0,Uint:1,Float:2}},{}],3:[function(require,module,exports){"use strict";var MeshTypes=require("./mesh-types"),isBigEndianPlatform=require("../utils/is-big-endian-platform");var InvertedEncodingTypes=[null,Float32Array,null,Int8Array,Int16Array,null,Int32Array,Uint8Array,Uint16Array,null,Uint32Array];var getMethods={Uint16Array:"getUint16",Uint32Array:"getUint32",Int16Array:"getInt16",Int32Array:"getInt32",Float32Array:"getFloat32",Float64Array:"getFloat64"};function copyFromBuffer(sourceArrayBuffer,viewType,position,length,fromBigEndian){var bytesPerElement=viewType.BYTES_PER_ELEMENT,result;if(fromBigEndian===isBigEndianPlatform()||bytesPerElement===1){result=new viewType(sourceArrayBuffer,position,length)}else{var readView=new DataView(sourceArrayBuffer,position,length*bytesPerElement),getMethod=getMethods[viewType.name],littleEndian=!fromBigEndian;result=new viewType(length);for(var i=0;i<length;i++){result[i]=readView[getMethod](i*bytesPerElement,littleEndian)}}return result}function decode(buffer){var array=new Uint8Array(buffer),version=array[0],flags=array[1],meshType=flags>>7&1,isTriangleMesh=meshType===MeshTypes.TriangleMesh,indicesType=flags>>6&1,bigEndian=(flags>>5&1)===1,attributesNumber=flags&31,valuesNumber=0,elementNumber=0;if(bigEndian){valuesNumber=(array[2]<<16)+(array[3]<<8)+array[4];elementNumber=(array[5]<<16)+(array[6]<<8)+array[7]}else{valuesNumber=array[2]+(array[3]<<8)+(array[4]<<16);elementNumber=array[5]+(array[6]<<8)+(array[7]<<16)}var pos=8;var attributes={},attributeName,char,attributeType,cardinality,encodingType,arrayType,values,i;for(i=0;i<attributesNumber;i++){attributeName="";while(pos<array.length){char=array[pos];pos++;if(char===0){break}else{attributeName+=String.fromCharCode(char)}}flags=array[pos];attributeType=flags>>6&3;cardinality=(flags>>4&3)+1;encodingType=flags&15;arrayType=InvertedEncodingTypes[encodingType];pos++;pos=Math.ceil(pos/4)*4;values=copyFromBuffer(buffer,arrayType,pos,cardinality*valuesNumber,bigEndian);pos+=arrayType.BYTES_PER_ELEMENT*cardinality*valuesNumber;attributes[attributeName]={type:attributeType,cardinality:cardinality,values:values}}pos=Math.ceil(pos/4)*4;var indices;if(isTriangleMesh){indices=copyFromBuffer(buffer,indicesType===1?Uint32Array:Uint16Array,pos,elementNumber*3,bigEndian)}else{indices=new(elementNumber>65535?Uint32Array:Uint16Array)(elementNumber);for(i=0;i<elementNumber;i++){indices[i]=i}}return{version:version,meshType:meshType,elements:elementNumber,attributes:attributes,indices:indices}}module.exports=decode},{"../utils/is-big-endian-platform":6,"./mesh-types":5}],4:[function(require,module,exports){"use strict";var MeshTypes=require("./mesh-types"),isBigEndianPlatform=require("../utils/is-big-endian-platform");var EncodingTypes={Float32Array:1,Int8Array:3,Int16Array:4,Int32Array:6,Uint8Array:7,Uint16Array:8,Uint32Array:10};var setMethods={Uint16Array:"setUint16",Uint32Array:"setUint32",Int16Array:"setInt16",Int32Array:"setInt32",Float32Array:"setFloat32",Float64Array:"setFloat64"};function copyToBuffer(sourceTypedArray,destinationArrayBuffer,position,length,bigEndian){var writeArray=new sourceTypedArray.constructor(destinationArrayBuffer,position,length),bytesPerElement=sourceTypedArray.BYTES_PER_ELEMENT;if(bigEndian===isBigEndianPlatform()||bytesPerElement===1){writeArray.set(sourceTypedArray.subarray(0,length))}else{var writeView=new DataView(destinationArrayBuffer,position,length*bytesPerElement),setMethod=setMethods[sourceTypedArray.constructor.name],littleEndian=!bigEndian,i=0;for(i=0;i<length;i++){writeView[setMethod](i*bytesPerElement,sourceTypedArray[i],littleEndian)}}return writeArray}function encode(meshType,attributes,indices,bigEndian){var attributeKeys=Object.keys(attributes),isTriangleMesh=meshType===MeshTypes.TriangleMesh;if(meshType<0||meshType>1){throw new Error("PRWM encoder: Incorrect mesh type")}if(attributeKeys.length===0){throw new Error("PRWM encoder: The model must have at least one attribute")}if(isTriangleMesh&&indices.constructor.name!=="Uint16Array"&&indices.constructor.name!=="Uint32Array"){throw new Error("PRWM encoder: The indices must be represented as an Uint16Array or an Uint32Array")}var valuesNumber=attributes[attributeKeys[0]].values.length/attributes[attributeKeys[0]].cardinality|0,elementNumber=isTriangleMesh?indices.length/3|0:valuesNumber,indicesType=!isTriangleMesh||indices.constructor.name==="Uint16Array"?0:1;var totalLength=8,attributeKey,attribute,attributeLength,i,j;for(i=0;i<attributeKeys.length;i++){attributeKey=attributeKeys[i];attribute=attributes[attributeKey];attributeLength=attributeKey.length+2;attributeLength=Math.ceil(attributeLength/4)*4+attribute.values.byteLength;totalLength+=attributeLength}totalLength=Math.ceil(totalLength/4)*4;if(isTriangleMesh){totalLength+=indices.byteLength}var buffer=new ArrayBuffer(totalLength),array=new Uint8Array(buffer);array[0]=1;array[1]=meshType<<7|indicesType<<6|(bigEndian?1:0)<<5|attributeKeys.length&31;if(bigEndian){array[2]=valuesNumber>>16&255;array[3]=valuesNumber>>8&255;array[4]=valuesNumber&255;array[5]=elementNumber>>16&255;array[6]=elementNumber>>8&255;array[7]=elementNumber&255}else{array[2]=valuesNumber&255;array[3]=valuesNumber>>8&255;array[4]=valuesNumber>>16&255;array[5]=elementNumber&255;array[6]=elementNumber>>8&255;array[7]=elementNumber>>16&255}var pos=8;for(i=0;i<attributeKeys.length;i++){attributeKey=attributeKeys[i];attribute=attributes[attributeKey];for(j=0;j<attributeKey.length;j++,pos++){array[pos]=attributeKey.charCodeAt(j)&127||95}pos++;array[pos]=(attribute.type&3)<<6|(attribute.cardinality-1&3)<<4|EncodingTypes[attribute.values.constructor.name]&15;pos++;pos=Math.ceil(pos/4)*4;var attributesWriteArray=copyToBuffer(attribute.values,buffer,pos,attribute.cardinality*valuesNumber,bigEndian);pos+=attributesWriteArray.byteLength}pos=Math.ceil(pos/4)*4;if(isTriangleMesh){copyToBuffer(indices,buffer,pos,elementNumber*3,bigEndian)}return buffer}module.exports=encode},{"../utils/is-big-endian-platform":6,"./mesh-types":5}],5:[function(require,module,exports){"use strict";module.exports={PointCloud:0,TriangleMesh:1}},{}],6:[function(require,module,exports){"use strict";var bigEndianPlatform=null;function isBigEndianPlatform(){if(bigEndianPlatform===null){var buffer=new ArrayBuffer(2),uint8Array=new Uint8Array(buffer),uint16Array=new Uint16Array(buffer);uint8Array[0]=170;uint8Array[1]=187;bigEndianPlatform=uint16Array[0]===43707}return bigEndianPlatform}module.exports=isBigEndianPlatform},{}]},{},[1])(1)});